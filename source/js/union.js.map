{"version":3,"sources":["components/form/form.js","skins/ilr/frame.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"union.js","sourcesContent":["(function (document) {\n\n  document.addEventListener('change', function(event) {\n    if (event.target.matches('.cu-input')) {\n      let wrapper = event.target.closest('.cu-input-list__item');\n\n      if (event.target.value) {\n        event.target.classList.add('is-filled');\n        wrapper.classList.add('is-filled');\n      }\n      else {\n        event.target.classList.remove('is-filled');\n        wrapper.classList.remove('is-filled');\n      }\n    }\n  }, false);\n\n  // This is the equivalent of focus (which doesnt' bubble).\n  document.addEventListener('focusin', function(event) {\n    if (event.target.matches('.cu-input')) {\n      let wrapper = event.target.closest('.cu-input-list__item');\n\n      event.target.classList.remove('is-touched');\n      event.target.classList.add('is-focused');\n\n      // Check for wrapper and update classes.\n      if (wrapper) {\n        wrapper.classList.add('is-active')\n      }\n\n      // If there were server-side errors, the 'is-invalid' class will be present\n      // but should be removed on focus because the user is trying to fix them.\n      event.target.classList.remove('is-invalid');\n\n      if (event.target.errors) {\n        event.target.errors.remove();\n      }\n    }\n  }, false);\n\n  // This is the equivalent of blur (which doesnt' bubble).\n  document.addEventListener('focusout', function(event) {\n    if (event.target.matches('.cu-input')) {\n      let wrapper = event.target.closest('.cu-input-list__item');\n\n      if (!event.isTrusted) {\n        // This blur event was triggered by a script, not a human, so don't mark\n        // the input as is-touched (because it actually wasn't) or show errors.\n\n        // Note that Mozilla claims that isTrusted shouldn't work in IE, but\n        // based on testing, it does.\n        // https://developer.mozilla.org/en-US/docs/Web/API/Event/isTrusted\n        return;\n      }\n\n      event.target.classList.add('is-touched');\n      event.target.classList.remove('is-focused');\n\n      // Check for wrapper and update classes\n      if (wrapper) {\n        wrapper.classList.remove('is-active');\n      }\n    }\n  }, false);\n\n  // Process any .cu-input elements whenever stuff is added to the DOM. This\n  // includes the initial page load.\n  let observer = new MutationObserver(function(mutations, observer) {\n    // Check to see if any of the mutations added nodes to the DOM.\n    let added_children = false;\n\n    for (const mutation of mutations) {\n      if (mutation.type === 'childList' && mutation.addedNodes.length) {\n        added_children = true;\n        break;\n      }\n    }\n\n    // Return if not adding children.\n    if (!added_children) {\n      return;\n    }\n\n    const inputs = document.querySelectorAll('.cu-input');\n\n    for (const input of inputs) {\n      const wrapper = input.closest('.cu-input-list__item');\n\n      // Check if the field has pre-filled text from the server side.\n      if (input.value) {\n        input.classList.add('is-filled');\n\n        // Check if input has a wrapper.\n        if (wrapper) {\n          wrapper.classList.add('is-filled');\n        }\n      }\n\n      // If wrapper, remove the js-disabled class for float labels.\n      if (wrapper) {\n        wrapper.classList.remove('js-disabled');\n      }\n    }\n  });\n\n  // @todo Investigate the performance ramifications of observing the entire\n  // document, plus its children.\n  observer.observe(document, {\n    childList: true,\n    subtree: true\n  });\n\n})(document);\n","(function(window, document) {\n\n  // Return an object with the padding values of a given element.\n  const getPadding = function(el) {\n    return {\n      top: Math.ceil(parseInt(window.getComputedStyle(el).getPropertyValue('padding-top'))),\n      right: Math.ceil(parseInt(window.getComputedStyle(el).getPropertyValue('padding-right'))),\n      bottom: Math.ceil(parseInt(window.getComputedStyle(el).getPropertyValue('padding-bottom'))),\n      left: Math.ceil(parseInt(window.getComputedStyle(el).getPropertyValue('padding-left')))\n    };\n  };\n\n  // Draw (or re-draw) decorative ILR Brand frames around any box content.\n  const drawFrames = function() {\n    const frame_targets = document.querySelectorAll('[data-cu-frame-style]');\n\n    for (const frame_target of frame_targets) {\n      let frame_canvas,\n          frame_target_dimensions = frame_target.getBoundingClientRect(),\n          padding_top = getPadding(frame_target).top,\n          padding_right = getPadding(frame_target).right,\n          padding_bottom = getPadding(frame_target).bottom,\n          padding_left = getPadding(frame_target).left,\n          style = frame_target.dataset.cuFrameStyle,\n          color = frame_target.dataset.cuFrameColor || 'white',\n          line_width = parseInt(frame_target.dataset.cuFrameSize) || 20,\n          bevel_size = line_width/10;\n\n      for (const frame_target_child of frame_target.children) {\n        // Check for an existing frame canvas.\n        if (frame_target_child.matches('canvas.cu-frame')) {\n          frame_canvas = frame_target_child;\n        }\n\n        // If the current padding is 0, get the padding from the first child that has any.\n        if (padding_top === 0) {\n          padding_top = getPadding(frame_target_child).top;\n        }\n\n        if (padding_right === 0) {\n          padding_right = getPadding(frame_target_child).right;\n        }\n\n        if (padding_bottom === 0) {\n          padding_bottom = getPadding(frame_target_child).bottom;\n        }\n\n        if (padding_left === 0) {\n          padding_left = getPadding(frame_target_child).left;\n        }\n      }\n\n      // Create and append a new frame canvas if one wasn't found.\n      if (typeof frame_canvas === 'undefined') {\n        frame_canvas = document.createElement('canvas');\n        // frame_canvas.setAttribute('id', 'todo-there-should-be-only-one');\n        frame_canvas.classList.add('cu-frame');\n        frame_canvas.style.cssText = 'position: absolute; top: 0; left: 0; pointer-events: none; z-index: 10';\n        frame_target.appendChild(frame_canvas);\n        frame_target.classList.add('cu-frame-target');\n        frame_target.style.position = 'relative';\n      }\n\n      // Assign the dimensions of the target element to the new or existing\n      // frame canvas.\n      frame_canvas.height = frame_target_dimensions.height;\n      frame_canvas.width = frame_target_dimensions.width;\n\n      let ctx = frame_canvas.getContext('2d');\n      ctx.imageSmoothingEnabled = false;\n\n      if (style === 'open-left') {\n        // Top after content to bottom before content.\n        // text ━━━┓\n        //         ┃\n        // foo ━━━━┛\n        let line_start = frame_target_dimensions.width - padding_right*2;\n\n        if (frame_target.children.length) {\n          let frame_target_first_child = frame_target.children[0];\n          line_start = frame_target_first_child.getBoundingClientRect().width - padding_right;\n        }\n\n        let line_0 = {\n              x: Math.ceil(line_start + padding_right/4),\n              y: Math.ceil(padding_top + line_width/2)\n            },\n            line_1 = {\n              x: Math.ceil(frame_target_dimensions.width - padding_left - line_width/2),\n              y: Math.ceil(padding_top + line_width/2)\n            },\n            line_2 = {\n              x: Math.ceil(frame_target_dimensions.width - padding_left - line_width/2),\n              y: Math.ceil(frame_target_dimensions.height - padding_top - line_width/2)\n            },\n            line_3 = {\n              x: Math.ceil(frame_target_dimensions.width/2),\n              y: Math.ceil(frame_target_dimensions.height - padding_top - line_width/2)\n            };\n\n        ctx.beginPath();\n        ctx.moveTo(line_0.x, line_0.y);\n        ctx.lineTo(line_1.x, line_1.y);\n        ctx.lineTo(line_2.x, line_2.y);\n        ctx.lineTo(line_3.x, line_3.y);\n        ctx.lineWidth = line_width;\n        ctx.strokeStyle = color;\n        ctx.stroke();\n\n        // Begin clipped bevels.\n        ctx.beginPath();\n\n        // All bevels are tiny triangles drawn at the ends and corners of lines.\n        // Line ends and outer corners are 'notched out', so the destination-out\n        // composite is used.\n        ctx.globalCompositeOperation = 'destination-out';\n\n        // Beginning of line outside.\n        ctx.moveTo(line_0.x, line_0.y - line_width/2);\n        ctx.lineTo(line_0.x, line_0.y - line_width/2 + bevel_size);\n        ctx.lineTo(line_0.x + bevel_size, line_0.y - line_width/2);\n\n        // Beginning of line inside.\n        ctx.moveTo(line_0.x, line_0.y + line_width/2);\n        ctx.lineTo(line_0.x, line_0.y + line_width/2 - bevel_size);\n        ctx.lineTo(line_0.x + bevel_size, line_0.y + line_width/2);\n\n        // End of line inside.\n        ctx.moveTo(line_3.x, line_3.y - line_width/2);\n        ctx.lineTo(line_3.x, line_3.y - line_width/2 + bevel_size);\n        ctx.lineTo(line_3.x + bevel_size, line_3.y - line_width/2);\n\n        // End of line outside.\n        ctx.moveTo(line_3.x, line_3.y + line_width/2);\n        ctx.lineTo(line_3.x, line_3.y + line_width/2 - bevel_size);\n        ctx.lineTo(line_3.x + bevel_size, line_3.y + line_width/2);\n\n        // First corner outside.\n        ctx.moveTo(line_1.x + line_width/2, line_1.y - line_width/2);\n        ctx.lineTo(line_1.x + line_width/2, line_1.y - line_width/2 + bevel_size);\n        ctx.lineTo(line_1.x + line_width/2 - bevel_size, line_1.y - line_width/2);\n\n        // Second corner outside.\n        ctx.moveTo(line_2.x + line_width/2, line_2.y + line_width/2);\n        ctx.lineTo(line_2.x + line_width/2, line_2.y + line_width/2 - bevel_size);\n        ctx.lineTo(line_2.x + line_width/2 - bevel_size, line_2.y + line_width/2);\n\n        ctx.fill();\n\n        // Inner bevels are visible in the inner corners of the frame.\n        ctx.beginPath();\n        ctx.globalCompositeOperation = 'source-over';\n        ctx.fillStyle = color;\n\n        // First corner inside.\n        ctx.moveTo(line_1.x - line_width/2, line_1.y + line_width/2);\n        ctx.lineTo(line_1.x - line_width/2 - bevel_size, line_1.y + line_width/2);\n        ctx.lineTo(line_1.x - line_width/2, line_1.y + line_width/2 + bevel_size);\n\n        // Second corner inside.\n        ctx.moveTo(line_2.x - line_width/2, line_2.y - line_width/2);\n        ctx.lineTo(line_2.x - line_width/2, line_2.y - line_width/2 - bevel_size);\n        ctx.lineTo(line_2.x - line_width/2 - bevel_size, line_2.y - line_width/2);\n\n        ctx.fill();\n      }\n      else if (style === 'open-right') {\n        // This frame lives in the available padding of the frame target.\n        // ┏━━━━━━━━\n        // ┃ content\n        // ┗━━━━\n        let line_0 = {\n          x: Math.ceil(frame_target_dimensions.width - padding_right),\n          y: Math.ceil(padding_top/2)\n        },\n        line_1 = {\n          x: Math.ceil(padding_left/2),\n          y: Math.ceil(padding_top/2)\n        },\n        line_2 = {\n          x: Math.ceil(padding_left/2),\n          y: Math.ceil(frame_target_dimensions.height - padding_top/2)\n        },\n        line_3 = {\n          x: Math.ceil(frame_target_dimensions.width/2),\n          y: Math.ceil(frame_target_dimensions.height - padding_top/2)\n        };\n\n        ctx.beginPath();\n        ctx.moveTo(line_0.x, line_0.y);\n        ctx.lineTo(line_1.x, line_1.y);\n        ctx.lineTo(line_2.x, line_2.y);\n        ctx.lineTo(line_3.x, line_3.y);\n        ctx.lineWidth = line_width;\n        ctx.strokeStyle = color;\n        ctx.stroke();\n\n        // Begin clipped bevels.\n        ctx.beginPath();\n        ctx.globalCompositeOperation = 'destination-out';\n\n        // Beginning of line outside.\n        ctx.moveTo(line_0.x, line_0.y - line_width/2);\n        ctx.lineTo(line_0.x, line_0.y - line_width/2 + bevel_size);\n        ctx.lineTo(line_0.x - bevel_size, line_0.y - line_width/2);\n\n        // Beginning of line inside.\n        ctx.moveTo(line_0.x, line_0.y + line_width/2);\n        ctx.lineTo(line_0.x, line_0.y + line_width/2 - bevel_size);\n        ctx.lineTo(line_0.x - bevel_size, line_0.y + line_width/2);\n\n        // End of line inside.\n        ctx.moveTo(line_3.x, line_3.y - line_width/2);\n        ctx.lineTo(line_3.x, line_3.y - line_width/2 + bevel_size);\n        ctx.lineTo(line_3.x - bevel_size, line_3.y - line_width/2);\n\n        // End of line outside.\n        ctx.moveTo(line_3.x, line_3.y + line_width/2);\n        ctx.lineTo(line_3.x, line_3.y + line_width/2 - bevel_size);\n        ctx.lineTo(line_3.x - bevel_size, line_3.y + line_width/2);\n\n        // First corner outside.\n        ctx.moveTo(line_1.x - line_width/2, line_1.y - line_width/2);\n        ctx.lineTo(line_1.x - line_width/2, line_1.y - line_width/2 + bevel_size);\n        ctx.lineTo(line_1.x - line_width/2 + bevel_size, line_1.y - line_width/2);\n\n        // Second corner outside.\n        ctx.moveTo(line_2.x - line_width/2, line_2.y + line_width/2);\n        ctx.lineTo(line_2.x - line_width/2, line_2.y + line_width/2 - bevel_size);\n        ctx.lineTo(line_2.x - line_width/2 + bevel_size, line_2.y + line_width/2);\n\n        ctx.fill();\n\n        // Inner bevels are visible in the inner corners of the frame.\n        ctx.beginPath();\n        ctx.globalCompositeOperation = 'source-over';\n        ctx.fillStyle = color;\n\n        // First corner inside.\n        ctx.moveTo(line_1.x + line_width/2, line_1.y + line_width/2);\n        ctx.lineTo(line_1.x + line_width/2 + bevel_size, line_1.y + line_width/2);\n        ctx.lineTo(line_1.x + line_width/2, line_1.y + line_width/2 + bevel_size);\n\n        // Second corner inside.\n        ctx.moveTo(line_2.x + line_width/2, line_2.y - line_width/2);\n        ctx.lineTo(line_2.x + line_width/2, line_2.y - line_width/2 - bevel_size);\n        ctx.lineTo(line_2.x + line_width/2 + bevel_size, line_2.y - line_width/2);\n\n        ctx.fill();\n\n      }\n    }\n  };\n\n  // Set a simple debounce timer to prevent the following redraw triggers from\n  // running more often than necessary.\n  let debounce_timeout;\n\n  // Trigger a frame draw when the DOM is modified, including initial page load.\n  let observer = new MutationObserver(function() {\n    clearTimeout(debounce_timeout);\n    debounce_timeout = setTimeout(drawFrames, 250);\n  }).observe(document, {\n    childList: true,\n    subtree: true\n  });\n\n  // Trigger a frame draw when the window/viewport is resized.\n  window.addEventListener('resize', drawFrames, false);\n\n  // This is the debounced version, which only draws the frames once the window\n  // resize is done. This is only required if there are performace issues with\n  // firing on every resize event.\n  // window.addEventListener('resize', function(event) {\n  //   clearTimeout(debounce_timeout);\n  //   debounce_timeout = setTimeout(drawFrames, 100);\n  // }, false);\n\n})(window, document);\n"]}