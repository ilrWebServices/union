{"version":3,"sources":["components/dismissible/dismissible.js","components/form/form.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"union.js","sourcesContent":["(function (window, document) {\n\n  // Test for required browser APIs.\n  if (('TextEncoder' in window) === false) {\n    return;\n  }\n\n  if ((('crypto' in window) || ('subtle' in window.crypto)) === false) {\n    return;\n  }\n\n  if (('localStorage' in window) === false) {\n    return;\n  }\n\n  const hashElement = function(el) {\n    // Create a new TextEncoder.\n    // https://developer.mozilla.org/en-US/docs/Web/API/TextEncoder\n    const encoder = new TextEncoder();\n\n    // Encode element innerHTML into a Uint8Array object.\n    const element_encoded = encoder.encode(el.innerHTML);\n\n    // Create a digest string of the encoded HTML Element.\n    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest\n    crypto.subtle.digest('SHA-1', element_encoded).then(digest_val => {\n      const byteArray = new Uint8Array(digest_val);\n\n      const hexCodes = [...byteArray].map(value => {\n        const hexCode = value.toString(16);\n        const paddedHexCode = hexCode.padStart(2, '0');\n        return paddedHexCode;\n      });\n\n      processHashedElement(el, hexCodes.join(''));\n    });\n  };\n\n  const processHashedElement = function(el, hash) {\n    // Add a data attribute with the hash value on the dismissible element.\n    el.setAttribute('data-cu-sha256', hash);\n\n    // Has this element been dismissed? Remove it from the DOM if so.\n    if (parseInt(localStorage.getItem('cu-diss-' + hash))) {\n      el.classList.add('cu-dismissible--predismissed')\n    }\n    else {\n      el.classList.remove('cu-dismissible--predismissed');\n    }\n  };\n\n  const hashElements = function() {\n    const dismissible_elements = document.querySelectorAll('.cu-dismissible');\n\n    for (const dismissible_element of dismissible_elements) {\n      hashElement(dismissible_element);\n    }\n  };\n\n  // Set a simple debounce timer to prevent the following trigger from running\n  // more often than necessary.\n  let debounce_timeout;\n\n  // Trigger dismissible hash processing when the DOM is modified, including\n  // initial page load.\n  let observer = new MutationObserver(function() {\n    clearTimeout(debounce_timeout);\n    debounce_timeout = setTimeout(hashElements, 250);\n  }).observe(document, {\n    childList: true,\n    subtree: true\n  });\n\n  // Store the dismissal state in local storage.\n  document.addEventListener('change', function(event) {\n    if (event.target.matches('.cu-dismissible__input')) {\n      localStorage.setItem('cu-diss-' + event.target.parentNode.dataset.cuSha256, event.target.checked ? 1 : 0);\n    }\n  }, false);\n\n})(window, document);\n","(function (document) {\n\n  document.addEventListener('change', function(event) {\n    if (event.target.matches('.cu-input')) {\n      let wrapper = event.target.closest('.cu-input-list__item');\n\n      if (event.target.value) {\n        event.target.classList.add('is-filled');\n        wrapper.classList.add('is-filled');\n      }\n      else {\n        event.target.classList.remove('is-filled');\n        wrapper.classList.remove('is-filled');\n      }\n    }\n  }, false);\n\n  // This is the equivalent of focus (which doesnt' bubble).\n  document.addEventListener('focusin', function(event) {\n    if (event.target.matches('.cu-input')) {\n      let wrapper = event.target.closest('.cu-input-list__item');\n\n      event.target.classList.remove('is-touched');\n      event.target.classList.add('is-focused');\n\n      // Check for wrapper and update classes.\n      if (wrapper) {\n        wrapper.classList.add('is-active')\n      }\n\n      // If there were server-side errors, the 'is-invalid' class will be present\n      // but should be removed on focus because the user is trying to fix them.\n      event.target.classList.remove('is-invalid');\n\n      if (event.target.errors) {\n        event.target.errors.remove();\n      }\n    }\n  }, false);\n\n  // This is the equivalent of blur (which doesnt' bubble).\n  document.addEventListener('focusout', function(event) {\n    if (event.target.matches('.cu-input')) {\n      let wrapper = event.target.closest('.cu-input-list__item');\n\n      if (!event.isTrusted) {\n        // This blur event was triggered by a script, not a human, so don't mark\n        // the input as is-touched (because it actually wasn't) or show errors.\n\n        // Note that Mozilla claims that isTrusted shouldn't work in IE, but\n        // based on testing, it does.\n        // https://developer.mozilla.org/en-US/docs/Web/API/Event/isTrusted\n        return;\n      }\n\n      event.target.classList.add('is-touched');\n      event.target.classList.remove('is-focused');\n\n      // Check for wrapper and update classes\n      if (wrapper) {\n        wrapper.classList.remove('is-active');\n      }\n    }\n  }, false);\n\n  // Process any .cu-input elements whenever stuff is added to the DOM. This\n  // includes the initial page load.\n  let observer = new MutationObserver(function(mutations, observer) {\n    // Check to see if any of the mutations added nodes to the DOM.\n    let added_children = false;\n\n    for (const mutation of mutations) {\n      if (mutation.type === 'childList' && mutation.addedNodes.length) {\n        added_children = true;\n        break;\n      }\n    }\n\n    // Return if not adding children.\n    if (!added_children) {\n      return;\n    }\n\n    const inputs = document.querySelectorAll('.cu-input');\n\n    for (const input of inputs) {\n      const wrapper = input.closest('.cu-input-list__item');\n\n      // Check if the field has pre-filled text from the server side.\n      if (input.value) {\n        input.classList.add('is-filled');\n\n        // Check if input has a wrapper.\n        if (wrapper) {\n          wrapper.classList.add('is-filled');\n        }\n      }\n\n      // If wrapper, remove the js-disabled class for float labels.\n      if (wrapper) {\n        wrapper.classList.remove('js-disabled');\n      }\n    }\n  });\n\n  // @todo Investigate the performance ramifications of observing the entire\n  // document, plus its children.\n  observer.observe(document, {\n    childList: true,\n    subtree: true\n  });\n\n})(document);\n"]}